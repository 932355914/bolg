# Redis基础
### redis缓存知识点
![](https://github.com/932355914/bolg/blob/master/image/redis/redis.jpeg)

redis类型
一、string: 是redis最常用最普通的类型 一般就是 set和get

**string应用场景**
1. 缓冲数据:利用redis缓冲功能配合DB作为数据层,加快读取速度,降低数据库压力.
2. 计数器:快速实现计数和查询功能 方便统计数据.
3. 共享session: 多台服务器时同步登陆状态 更新/获取可以快速完成.

二、hash: 这个类似于 map 的一种数据格式 场景比较单一用起来比较少

**案例使用场景**: 
在一个学校里面 年级>班级>学生
hset(xxx_年级id,班级id,班级学生信息) 设置hash
读取年级下班级/学生
hgetall(xxx_年级id)
读取年级和班级下学生
hget(xxx_年级id,班级id)

三、list: 有序列表

**list应用场景**
1. 消息队列:使用左进右出的命令组成来完成队列的设计 抢购/排队
2. 列表/分页: 可以做一个全量的数据列表 分页等功能 但是不支持搜索....

四、set: 无序集合 (可以自动去重)

**set应用场景**
1. 数据对比:做差集/并集/交集 共同好友等功能

五、sorted set : 有序集合

**sset应用场景**
1. 排行榜 : 时间/点赞数/评论数/转发数的榜单
2. 权重队列:微博热搜榜 名称 => 热度

### 事务：
最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。

### 持久化
Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 Redis 处理的每一个写入或删除操作。
1. RDB 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。
2. AOF 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。

## 缓存常见问题
### 缓存更新方式
这是决定在使用缓存时就该考虑的问题。
缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。更新的方式可以是主动更新。数据源是 DB 时，可以在更新完 DB 后就直接更新缓存。

当数据源不是 DB 而是其他远程服务，可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。

这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。

但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。

### 数据不一致
**数据不一致的问题:** 可以说只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 Redis 因为网络原因请求超时；或者是异步更新失败导致。

**解决的办法:** 如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。

### 缓存穿透
**缓存穿透:** 产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户id频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。

**解决的办法**
1. 对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。
2. 使用 BloomFilter 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。


### 缓存击穿
**缓存击穿:** 就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。

**解决方法:**
1. 可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。
2. 使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。
3. 针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。


### 缓存雪崩
**缓存雪崩:** 产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。

**解决方法：**
1. 使用快速失败的熔断策略，减少 DB 瞬间压力；
2. 使用主从模式和集群模式来尽量保证缓存服务的高可用。



    
